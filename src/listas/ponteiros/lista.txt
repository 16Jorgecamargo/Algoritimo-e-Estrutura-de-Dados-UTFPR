=== Lista de Exercicios - Ponteiros ===

QUESTAO 01:
Enunciado: Sendo p um ponteiro, qual a diferenca entre:
-> p++;
-> (*p)++;
-> *(p++);
-> *(p+10);

Logica utilizada:
Pelo que eu entendo de ponteiros quando a gente tem um ponteiro exemplo: INT *P
e manuseamos ele somente com o p estamos retratando o endereco que ele esta apontando e 
quando fizemos isso com o asteristico estamos retratando ao conteudo.

ou seja:

p  => Endereco;
*p => Conteudo;

- `p++` move o ponteiro para o proximo elemento (endereco diferente, mesmo conteudo).
- `(*p)++` incrementa o valor armazenado no endereco apontado (endereco igual).
- `*(p++)` usa o valor atual e so depois avanca o endereco (pos-incremento).
- `*(p+10)` acessa uma posicao relativa sem alterar o ponteiro; se a posicao nao existir, o acesso e invalido.

---

QUESTAO 02:
Enunciado: Escreva um comentario em cada comando de atribuicao explicando o que
ele faz e o valor da variavel a esquerda do '=' apos sua execucao.
int main()
{
  int y, *p, x;
  y = 0;
  p = &y;
  x = *p;
  x = 4;
  (*p)++;
  x--;
  (*p) += x;
  printf ("y = %d\n", y);
  return(0);
} 

Logica utilizada:
A logica eh que tecnicamente y e p sao a mesma coisa pois quando atribuimos o endereco de y a p,
quando manipulamos o p, estamos manimulando o y.

- `p = &y` faz p apontar para y; `*p` passa a enxergar o mesmo valor de y.
- `x = *p` copia o valor apontado por p para x (neste ponto x = y).
- `(*p)++` altera diretamente y porque p aponta para ele.
- `(*p) += x` soma o valor atual de x no conteudo de y via ponteiro duplo, alterando y novamente.
- O rastreamento linha a linha evidencia que variaveis ligadas por ponteiros compartilham o mesmo armazenamento.

---

QUESTAO 03:
Enunciado: Verifique o programa abaixo. Encontre o seu erro e corrija-o para que
escreva o numero 10 na tela.
#include <stdio.h>
int main() {
 int x, *p, **q;
 p = &x;
 q = &p;
 x = 10;
 printf("\n%d\n", &q);
 return(0);
}

Logica utilizada:
Primeiramente o &q esta tentando passar o endereco de q ao inves do conteudo de q,
entao so corrigi o que ele estava passado para o %d.
mas mesmo se ele quisesse mostrar o endereco do q no console nao seria dessa forma. 
usaria printf("%p",(void *)&q);

- `q` guarda o endereco de `p` (ponteiro para ponteiro); `*q` devolve o endereco de `x`.
- Para chegar ao valor armazenado em `x` e necessario aplicar duas dereferencias: `**q`.
- Imprimir `&q` mostra somente o endereco da variavel ponteiro, nao o valor desejado.

---

QUESTAO 04:
Enunciado: Crie um vetor V com n inteiros, onde n eh um valor inteiro fornecido pelo
usuario. O vetor so deve ser alocado na memoria depois que o usuario
fornecer o valor de n.

Exemplo de entrada: 9
Exemplo de saida: v[9] = {1,2,3,4,5,6,7,8,9}

Logica utilizada:
A logica que eu usei foi so criar um vetor sem tamanho defino inicialmente, 
e alocar ele com o malloc e com o tamanho passado pelo usuario.

- A chamada `malloc(n * sizeof(int))` deve ocorrer somente depois que `n` e fornecido.
- Após alocar, o programa preenche o vetor e imprime os valores para confirmar.
- Ao final, `free()` e obrigatório para liberar a memória dinâmica e evitar vazamentos.

---

QUESTAO 05:
Enunciado: Crie um programa para manipular vetores com ponteiros. O seu programa
deve implementar uma funcao chamada inverte_vetor, que recebe como
parametro dois vetores V1 e V2, ambos de tamanho N. A funcao deve copiar
os elementos de V1 para V2 na ordem inversa. Ou seja, se a funcao receber
V1 = {1,2,3,4,5}, a funcao deve copiar os elementos para V2 na seguinte
ordem: V2 = {5,4,3,2,1}. Alem disso, a funcao tambem deve retornar o maior
valor encontrado em V1. A funcao deve obedecer ao seguinte prototipo: 
int inverte_vetor(int *v1, int *v2, int n).

Exemplo de entrada: v1 = {3,5,2,1,6,2,7}
Exemplo de saida: v2 = {7,2,6,1,2,5,3}

Logica utilizada:
A ideia que eu usei foi de pegar um vetor e povoar outro com os elementos na ordem inversa.
se eu tenho {1,2,3,4,5}, 
quero que o novo fique {5,4,3,2,1}

e para pegar o maior so comparei os conteudos do vetor, 
atribuindo a uma variavel quando era maior.

- A função percorre uma única vez: copia `v1[n-1-i]` para `v2[i]` e atualiza o maior elemento.
- Retornar o maior evita uma segunda passagem para procurar o valor máximo.

---

QUESTAO 06:
Enunciado: Escreva um programa em linguagem C que imprimam na tela a string s na
ordem inversa utilizando ponteiros.
char s[10] = "abcde";
char* cptr;

Exemplo de entrada: "abcde"
Exemplo de saida: "edcba"

Logica utilizada:
A logica que usei foi de usar recursao pra imprimir a string de tras pra frente ate chegar no '\0',
ela volta imprimindo cada caractere como se fosse um pilha.

- O ponteiro avanca ate o terminador `\\0`; cada retorno imprime um caractere, produzindo a string invertida.
- Não há alocação adicional: a pilha de chamadas fornece a ordem reversa automaticamente.

---

QUESTAO 07:
Enunciado: Escrever um programa que cadastre varios produtos em uma
estrutura/registro. Em seguida, imprima uma lista com o codigo e nome da
cada produto. Por ultimo, consulte o preco de um produto atraves de seu
codigo.

Exemplo de entrada: 15
Exemplo de saida: 
== produto encontrado ==
produto: Feijao,
preco: R$ 10,00
codigo: 15                          

Logica utilizada:
A logica que usei foi definir uma struct como produto e nele ter o nome, preco e codigo do produto,
entao depois bastou alocar ele uma quantidade x vezes para os produtos pre definidos,
e para adiconar produtos preferi realocar mais um espaco para o novo item,
para buscar o item bastou ele acessar o vetor de produtos e comparar se eh igual o codigo.

- Ponteiros permitem armazenar o endereço dos registros (`Produto`) e retornar diretamente o item encontrado.
- A listagem percorre o vetor dinâmico imprimindo cada struct; a busca retorna o ponteiro para o elemento ou `NULL`.
- O gerenciamento envolve `malloc` para o vetor inicial e `realloc`/`free` caso se deseje expandir ou liberar a lista.

---

QUESTAO 08:
Enunciado: Faca um programa que leia um valor n e crie dinamicamente um vetor de n
elementos e passe esse vetor para uma funcao que vai ler os elementos
desse vetor. Depois, no programa principal, o vetor preenchido deve ser
impresso. Alem disso, antes de finalizar o programa, deve-se liberar a area
de memoria alocada.

Logica utilizada:
A logica utilizada foi basicamente pedir ao usuario um numero para definir o tamanho do vetor,
depois alocar o tamanho dele, assim podendo preencher o vetor depois imprimindo o conteudo do vetor.

- A funcao que recebe o vetor preenchido trabalha sobre o ponteiro retornado por `malloc`.
- Ao final, `free(vetor)` deve ser chamado para liberar a memória antes de sair do programa.

---

QUESTAO 09:
Enunciado: Construa um programa (main) que aloque em tempo de execucao
(dinamicamente) uma matriz de ordem m x n (linha por coluna), usando 1+m
chamadas a funcao malloc. Agora, aproveite este programa para construir
uma funcao que recebendo os parametros m e n aloque uma matriz de ordem
m x n e retorne um ponteiro para esta matriz alocada. Crie ainda uma funcao
para liberar a area de memoria alocada pela matriz. Finalmente, crie um novo
programa (main) que teste/use as duas funcoes criadas acima.

Exemplo de entrada: m=3, n=4
Exemplo de saida:
Matriz 3x4:
[ 45, 12, 78, 23 ]
[ 56, 89, 34, 67 ]
[ 91, 28, 45, 73 ]

Logica utilizada:
A logica que usei foi alocar a matriz em duas etapas:
1. Primeira chamada a malloc: aloca um array de m ponteiros (int**), onde cada
   ponteiro vai apontar para uma linha da matriz.
2. M chamadas a malloc: para cada uma das m linhas, aloca um array de n inteiros.

Total: 1 + m chamadas a malloc!

Para liberar a memoria, faz-se o inverso:
1. M chamadas a free: libera cada uma das m linhas.
2. Uma chamada a free: libera o array de ponteiros.

Total: m + 1 chamadas a free!

Funcoes criadas:
- int** alocarMatriz(int m, int n): aloca e retorna a matriz
- void liberarMatriz(int** mat, int m): libera toda memoria alocada
- void preencherMatriz(int** mat, int m, int n): preenche com valores aleatorios
- void imprimirMatriz(int** mat, int m, int n): exibe a matriz formatada

Esta abordagem permite criar matrizes de qualquer tamanho em tempo de execucao,
acessando os elementos como matriz[i][j], mantendo a notacao tradicional.

---
